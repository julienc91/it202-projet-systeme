\documentclass[a4paper,11pt]{article}

\usepackage{lscape}
\usepackage{geometry}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{tikz}
\usepackage{relsize}
\usepackage{color}
\usepackage[boxed]{algorithm2e}
\usepackage[hidelinks]{hyperref}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\usepackage{listings}
\usepackage{float}
%\usepackage{kpfonts}

\usepackage{graphicx}
%\usepackage{rotating}

\lstset{
  language=C++,
  basicstyle=\footnotesize,
  backgroundcolor=\color{white},
  keywordstyle=\color{red},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  numberstyle=\color{red},
  morekeywords={string},
  frame=BL,
  aboveskip=1em,
  belowskip=2em,
}
\lstset{
  literate={ù}{{\`u}}1
  {é}{{\'e}}1
  {è}{{\'e}}1
  {à}{{\`a}}1
}


\lstdefinelanguage{tikzuml}{language=[LaTeX]TeX, classoffset=0, morekeywords={umlbasiccomponent, umlprovidedinterface, umlrequiredinterface, umldelegateconnector, umlassemblyconnector, umlVHVassemblyconnector, umlHVHassemblyconnector, umlnote, umlusecase, umlactor, umlinherit, umlassoc, umlVHextend, umlinclude, umlstateinitial, umlbasicstate, umltrans, umlstatefinal, umlVHtrans, umlHVtrans, umldatabase, umlmulti, umlobject, umlfpart, umlcreatecall, umlclass, umlvirt, umlunicompo, umlimport, umlaggreg}, classoffset=1, morekeywords={umlcomponent, umlsystem, umlstate, umlseqdiag, umlcall, umlcallself, umlfragment, umlpackage}, classoffset=0,  sensitive=true, morecomment=[l]{\%}}

\geometry{margin=2.5cm}
\geometry{headheight=15pt}

\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{float}
\usepackage[footnote,smaller]{acronym}

\pagestyle{fancy}
\rhead{IT202 - Projet de Système d'Exploitation}

% \acrodef{LABRI}{Laboratoire Bordelais de Recherche en Informatique}

\begin{document}

\begin{titlepage}
  \begin{center}

    \textsc{IT202 - Projet de Système d'Exploitation}\\[2cm]
    \textsc{\large Rapport Final}\\[3cm]
    Maxime \textsc{Bellier} \ \ \ Louis \textsc{Boucherie}\ \ \ Jean-Michaël \textsc{Celerier}\\
    Julien \textsc{Chaumont} \ \ \ Bazire \textsc{Houssin} \ \ \ Sylvain \textsc{Vaglica}\\[1cm]
    \textsc{Groupe 3}\\[1.5cm]
    \textsc{\large 23/05/2013 }\\[1.5cm] %TODO
    \includegraphics[width=8cm]{logo.png}

  \end{center}
  \vspace{3cm}

\end{titlepage}

\clearpage

\section*{Introduction}

Ce rapport final pour le projet de réseau IT202 fait suite au rapport intermédiaire délivré le 23 avril dernier.

\section{Préemption}

\subsection{Principe et utilité}

Afin de mieux intégrer le système de priorités élaboré précédemment, il fallait mettre en place une gestion de la préemption. En effet, sans préemption, les priorités n'opèrent que lorsque le thread courant \textit{choisit} de passer la main. On peut par exemple imaginer un thread non prioritaire s'exécutant sans jamais appeler au \textit{yield}, et s'exécuterait jusqu'à sa terminaison.

La préemption pallie ce problème en offrant, en quelque sorte, un \textit{arbitre} qui force le passage de main. Ainsi, la préemption rend le système de priorités utile dans tous les cas, et non plus seulement dans le cadre d'un code coopératif (\textit{ie} dont les fonctions font des \textit{yields} de leur propre chef et de manière régulière).

\subsection{Les bases de l'implémentation}

L'idée de base consiste simplement à voir l'ordonnanceur comme un superviseur s'exécutant en parallèle des threads. Pour permettre cette exécution simultanée, la mise en place s'est faite à l'aide d'un thread noyau (bibliothèque \texttt{pthread}) propre à l'ordonnanceur, tandis que les threads utilisateurs étaient exécutés depuis le thread noyau principal.

\subsubsection*{La remise à plat du système de priorités}

Comme évoqué dans le rapport précédent, le système de priorités mis en place s'avérait être complexe dans certains cas, notamment lorsque la différence de priorité entre deux threads était trop importante. L'algorithme donné en figure \ref{priority1} correspond à cette première version.

\begin{figure}[H]
\begin{algorithm}[H]
 thread = thread\_next(thread\_list$\rightarrow$current\_thread)\;
 continue = true\;
 \While{continue} {
 	thread$\rightarrow$current\_priority = thread$\rightarrow$current\_priority - 1\;
 	\tcc{Reset priority}
 	\If{thread$\rightarrow$current\_priority == thread$\rightarrow$default\_priority - thread\_list$\rightarrow$max\_priority} {
 			thread$\rightarrow$current\_priority = thread$\rightarrow$default\_priority\;
 		}
    \tcc{This thread can be executed}
 	\If{thread$\rightarrow$current\_priority > 0} {
 		continue = false\;
 	}
  }
  execute(thread)\;
\end{algorithm}
\caption{Première version des priorités}
\label{priority1}
\end{figure}


\section{Multithread}


\section*{Conclusion} %TODO
%tests, valgrind, réponse au sujet, code propre


\end{document}
