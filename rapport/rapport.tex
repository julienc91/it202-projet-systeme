\documentclass[a4paper,11pt]{article}

\usepackage{lscape}
\usepackage{geometry}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{tikz}
\usepackage{relsize}
\usepackage{color}
\usepackage[boxed]{algorithm2e}
\usepackage[hidelinks]{hyperref}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\usepackage{listings}
\usepackage{float}
%\usepackage{kpfonts}

\usepackage{graphicx}
%\usepackage{rotating}

\lstset{
  language=C++,
  basicstyle=\footnotesize,
  backgroundcolor=\color{white},
  keywordstyle=\color{red},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  numberstyle=\color{red},
  morekeywords={string},
  frame=BL,
  aboveskip=1em,
  belowskip=2em,
}
\lstset{
  literate={ù}{{\`u}}1
  {é}{{\'e}}1
  {è}{{\'e}}1
  {à}{{\`a}}1
}


\lstdefinelanguage{tikzuml}{language=[LaTeX]TeX, classoffset=0, morekeywords={umlbasiccomponent, umlprovidedinterface, umlrequiredinterface, umldelegateconnector, umlassemblyconnector, umlVHVassemblyconnector, umlHVHassemblyconnector, umlnote, umlusecase, umlactor, umlinherit, umlassoc, umlVHextend, umlinclude, umlstateinitial, umlbasicstate, umltrans, umlstatefinal, umlVHtrans, umlHVtrans, umldatabase, umlmulti, umlobject, umlfpart, umlcreatecall, umlclass, umlvirt, umlunicompo, umlimport, umlaggreg}, classoffset=1, morekeywords={umlcomponent, umlsystem, umlstate, umlseqdiag, umlcall, umlcallself, umlfragment, umlpackage}, classoffset=0,  sensitive=true, morecomment=[l]{\%}}

\geometry{margin=2.5cm}
\geometry{headheight=15pt}

\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{float}
\usepackage[footnote,smaller]{acronym}

\pagestyle{fancy}
\rhead{IT202 - Projet de Système d'Exploitation}

% \acrodef{LABRI}{Laboratoire Bordelais de Recherche en Informatique}

\begin{document}

\begin{titlepage}
  \begin{center}

    \textsc{IT202 - Projet de Système d'Exploitation}\\[2cm]
    \textsc{\large Rapport Final}\\[3cm]
    Maxime \textsc{Bellier} \ \ \ Louis \textsc{Boucherie}\ \ \ Jean-Michaël \textsc{Celerier}\\
    Julien \textsc{Chaumont} \ \ \ Bazire \textsc{Houssin} \ \ \ Sylvain \textsc{Vaglica}\\[1cm]
    \textsc{Groupe 3}\\[1.5cm]
    \textsc{\large 23/05/2013 }\\[1.5cm] %TODO
    \includegraphics[width=8cm]{logo.png}

  \end{center}
  \vspace{3cm}

\end{titlepage}

\clearpage

\section*{Introduction}

Ce rapport final pour le projet de réseau IT202 fait suite au rapport intermédiaire délivré le 23 avril dernier.

\section{Préemption}

\subsection{Principe et utilité}

Afin de mieux intégrer le système de priorités élaboré précédemment, il fallait mettre en place une gestion de la préemption. En effet, sans préemption, les priorités n'opèrent que lorsque le thread courant \textit{choisit} de passer la main. On peut par exemple imaginer un thread non prioritaire s'exécutant sans jamais appeler au \textit{yield}, et s'exécuterait jusqu'à sa terminaison.

La préemption pallie ce problème en offrant, en quelque sorte, un \textit{arbitre} qui force le passage de main. Ainsi, la préemption rend le système de priorités utile dans tous les cas, et non plus seulement dans le cadre d'un code coopératif (\textit{ie} dont les fonctions font des \textit{yields} de leur propre chef et de manière régulière).

\subsection{Les bases de l'implémentation}

L'idée de base consiste simplement à voir l'ordonnanceur comme un superviseur s'exécutant en parallèle des threads. Pour permettre cette exécution simultanée, la mise en place s'est faite à l'aide d'un thread noyau (bibliothèque \texttt{pthread}) propre à l'ordonnanceur, tandis que les threads utilisateurs étaient exécutés depuis le thread noyau principal.

\subsubsection*{La remise à plat du système de priorités}

Comme évoqué dans le rapport précédent, le système de priorités mis en place s'avérait être complexe dans certains cas, notamment lorsque la différence de priorité entre deux threads était trop importante. L'algorithme donné en figure \ref{priority1} correspond à cette première version.

\begin{figure}[H]
\begin{algorithm}[H]
 thread = thread\_next(thread\_list$\rightarrow$current\_thread)\;
 continue = true\;
 \While{continue} {
 	thread$\rightarrow$current\_priority = thread$\rightarrow$current\_priority - 1\;
 	\tcc{Reset priority}
 	\If{thread$\rightarrow$current\_priority == thread$\rightarrow$default\_priority - thread\_list$\rightarrow$max\_priority} {
 			thread$\rightarrow$current\_priority = thread$\rightarrow$default\_priority\;
 		}
    \tcc{This thread can be executed}
 	\If{thread$\rightarrow$current\_priority > 0} {
 		continue = false\;
 	}
  }
  execute(thread)\;
\end{algorithm}
\caption{Première version des priorités}
\label{priority1}
\end{figure}


\section{Multithread}

La section suivante expose l'implémentation faite des threads noyaux pour exécuter simultanément les threads utilisateurs.

\subsection{Réflexion et implémentation}

De manière simplifiée, au lieu d'un seul thread noyau, un tableau de threads noyaux sera utilisé, et chaque fois qu'un yield sera fait sur l'un des threads noyaux, le thread en tête de liste des threads prêts sera chargé. Derrière ce principe simple se cachent néanmoins des problèmes à résoudre.\\

Un changement a dû être opéré avant même de commencer la gestion multithread. Dans une première implémentation, le thread courant était stockés dans le champ \texttt{currentThread} de la structure \texttt{Threads} mais était aussi laissé en tête de la liste des thrads prêts. Ceci devient impossible lorsqu'il y a plusieurs threads courants simultanément. Ainsi lorsqu'un thread est chargé par un thread noyau, il est maintenant retiré de la liste des threads prêts.

Le second point a changé avant de pouvoir réellement commencer les multithreads est la protection des données. Pour éviter par exemple qu'un thread utilisateur soit attribué à deux threads noyaux en même temps, les accés à la liste des threads doivent être gérés. Ainsi les sections critiques ont été identifiées et encadrés par des verrouillages et déverrouillages de spinlocks. Ce sont toutes les zones du codes dans lesquelles sont faits des tests sur les listes de threads ou des modifications sur ces listes.\\

Concernant la gestion du multithreading, dans la structure \texttt{Threads}, le champ \texttt{currentThread} n'est plus de type \texttt{thread\_t} mais de type \texttt{thread\_t *}. Le champ \texttt{pthread\_t *pthreadTList} y a été ajouté : ce tableau stockera les threads noyaux. On remarque qu'on utilise la bibliothèque \texttt{pthread} pour les threads noyaux et les verrous.

Le tableau des threads noyaux est de taille le nombre de coeurs de la machine. Ce nombre est lu dans le fichier \texttt{/proc/cpuinfo} par la fonction \texttt{get\_cores}.


\iffalse
Initialisation
thread Yield

Utilisation d'un entier pour identifier les threads avec setspecific et getspecific
\fi

\subsection{Tests et problèmes}


\section*{Conclusion} %TODO
%tests, valgrind, réponse au sujet, code propre


\end{document}
